import matplotlib.pyplot as plt
import numpy as np

def rotate_x(radians):
    if not np.isscalar(radians):
        rotation_matrices = np.zeros([radians.shape[0], 4, 4])
        for i in range(radians.size):
            r = radians[i]
            c = np.cos(r)
            s = np.sin(r)
            rotation_matrices[i] = np.array([[1, 0, 0, 0],
                                            [0, c,-s, 0],
                                            [0, s, c, 0],
                                            [0, 0, 0, 1]])
        return rotation_matrices
    else:
        c = np.cos(radians)
        s = np.sin(radians)
        return np.array([[1, 0, 0, 0],
                        [0, c,-s, 0],
                        [0, s, c, 0],
                        [0, 0, 0, 1]])

def rotate_y(radians):
    if not np.isscalar(radians):
        rotation_matrices = np.zeros([radians.shape[0], 4, 4])
        for i in range(radians.size):
            r = radians[i]
            c = np.cos(r)
            s = np.sin(r)
            rotation_matrices[i] = np.array([[ c, 0, s, 0],
                                            [ 0, 1, 0, 0],
                                            [-s, 0, c, 0],
                                            [ 0, 0, 0, 1]])
        return rotation_matrices
    else:
        c = np.cos(radians)
        s = np.sin(radians)
        return np.array([[ c, 0, s, 0],
                        [ 0, 1, 0, 0],
                        [-s, 0, c, 0],
                        [ 0, 0, 0, 1]])

def rotate_z(radians):
    if not np.isscalar(radians):
        rotation_matrices = np.zeros([radians.shape[0], 4, 4])
        for i in range(radians.size):
            r = radians[i]
            c = np.cos(r)
            s = np.sin(r)
            rotation_matrices[i] = np.array([[c,-s, 0, 0],
                                            [s, c, 0, 0],
                                            [0, 0, 1, 0],
                                            [0, 0, 0, 1]])
        return rotation_matrices
    else:
        c = np.cos(radians)
        s = np.sin(radians)
        return np.array([[c,-s, 0, 0],
                        [s, c, 0, 0],
                        [0, 0, 1, 0],
                        [0, 0, 0, 1]])
    

def translate(x, y, z):
    return np.array([[1, 0, 0, x],
                     [0, 1, 0, y],
                     [0, 0, 1, z],
                     [0, 0, 0, 1]])

def project(K, X):
    """
    Computes the pinhole projection of a (3 or 4)xN array X using
    the camera intrinsic matrix K. Returns the pixel coordinates
    as an array of size 2xN.
    """
    uvw = K@X[:3,:]
    uvw /= uvw[2,:]
    return uvw[:2,:]

def draw_frame(K, T, scale=1):
    """
    Visualize the coordinate frame axes of the 4x4 object-to-camera
    matrix T using the 3x3 intrinsic matrix K.

    Control the length of the axes by specifying the scale argument.
    """
    X = T @ np.array([
        [0,scale,0,0],
        [0,0,scale,0],
        [0,0,0,scale],
        [1,1,1,1]])
    u,v = project(K, X)
    plt.plot([u[0], u[1]], [v[0], v[1]], color='red') # X-axis
    plt.plot([u[0], u[2]], [v[0], v[2]], color='green') # Y-axis
    plt.plot([u[0], u[3]], [v[0], v[3]], color='blue') # Z-axis
